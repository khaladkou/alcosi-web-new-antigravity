'use server'

import { prisma } from '@/lib/db'
import { revalidatePath } from 'next/cache'

const BASE_URL = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET || 'your-secret-key'

// 1. Contact Form Test
export async function runContactTest() {
    const url = `${BASE_URL}/api/contact`
    const payload = {
        name: 'System Test',
        email: 'test@system.local',
        subject: '[SYSTEM TEST] verification',
        message: 'This is a test message from the System Health Check.'
    }
    try {
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })

        if (!res.ok) throw new Error(`API Error: ${res.status} ${res.statusText}`)

        // Verify DB
        const submission = await prisma.contactSubmission.findFirst({
            where: { email: 'test@system.local' },
            orderBy: { createdAt: 'desc' }
        })

        if (!submission) throw new Error('Submission not found in DB')

        return { success: true, message: `Created submission ID: ${submission.id}` }
    } catch (e: any) {
        // Although contact API logs internally, we can log the test failure too if needed.
        // For now, relying on return value.
        return { success: false, error: `${e.message} (URL: ${url})` }
    }
}

// 2. Article Create Test
export async function runArticleCreateTest() {
    try {
        const article = await prisma.article.create({
            data: {
                status: 'published',
                publishedAt: new Date(),
                translations: {
                    create: {
                        locale: 'en',
                        slug: 'system-test-article-' + Date.now(),
                        title: '[SYSTEM TEST] Auto Generated Article',
                        contentHtml: '<p>This is a test article generated by the system health check.</p>',
                        metaTitle: 'Test Article',
                        metaDescription: 'Test Description'
                    }
                }
            }
        })

        // Log to Event Log
        await prisma.webhookLog.create({
            data: {
                provider: 'SYSTEM_TEST',
                method: 'INTERNAL',
                url: 'runArticleCreateTest',
                payload: { articleId: article.id },
                status: 200,
                response: { success: true, id: article.id }
            }
        })

        return { success: true, message: `Created Article ID: ${article.id}` }
    } catch (e: any) {
        // Log Failure
        await prisma.webhookLog.create({
            data: {
                provider: 'SYSTEM_TEST',
                method: 'INTERNAL',
                url: 'runArticleCreateTest',
                payload: {},
                status: 500,
                error: e.message
            }
        })
        return { success: false, error: e.message }
    }
}

// 3. View Analytics Test
export async function runViewTest() {
    try {
        // Find the test article or any article
        const article = await prisma.article.findFirst({
            where: { translations: { some: { title: { contains: '[SYSTEM TEST]' } } } }
        })

        if (!article) throw new Error('No test article found to view. Run Article Test first.')

        await prisma.articleView.create({
            data: { articleId: article.id }
        })

        // Log to Event Log
        await prisma.webhookLog.create({
            data: {
                provider: 'SYSTEM_TEST',
                method: 'INTERNAL',
                url: 'runViewTest',
                payload: { articleId: article.id },
                status: 200,
                response: { success: true }
            }
        })

        return { success: true, message: `Logged view for Article ID: ${article.id}` }
    } catch (e: any) {
        await prisma.webhookLog.create({
            data: {
                provider: 'SYSTEM_TEST',
                method: 'INTERNAL',
                url: 'runViewTest',
                payload: {},
                status: 500,
                error: e.message
            }
        })
        return { success: false, error: e.message }
    }
}

// 4. Webhook Success Test
export async function runWebhookSuccessTest() {
    const url = `${BASE_URL}/api/webhooks/content`
    const payload = {
        secret: WEBHOOK_SECRET,
        action: 'create',
        data: {
            slug: 'webhook-test-' + Date.now(),
            locale: 'en',
            title: '[SYSTEM TEST] Webhook Article',
            contentHtml: '<p>Created via Webhook Test</p>',
            metaTitle: 'Webhook Test',
            status: 'published',
            publishedAt: new Date().toISOString()
        }
    }

    try {
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })

        if (!res.ok) throw new Error(`Webhook API Error: ${res.status} ${res.statusText}`)

        return { success: true, message: 'Webhook sent successfully (200 OK)' }
    } catch (e: any) {
        const errorMsg = `${e.message} (URL: ${url})`
        // We can't log to DB easily here if DB write failed, but we return explicit error
        return { success: false, error: errorMsg }
    }
}

// 5. Webhook Error Test
export async function runWebhookErrorTest() {
    const url = `${BASE_URL}/api/webhooks/content`
    const payload = {
        secret: WEBHOOK_SECRET,
        action: 'error',
        data: {
            error: 'Simulated Error from System Test',
            details: { reason: 'Testing error reporting flow' },
            slug: 'failed-generation-test'
        }
    }
    try {
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })

        // The API returns 200 even for error reports (it logged it successfully)
        if (!res.ok) throw new Error(`Webhook API Failed: ${res.status} ${res.statusText}`)

        return { success: true, message: 'Error Report sent successfully' }
    } catch (e: any) {
        return { success: false, error: `${e.message} (URL: ${url})` }
    }
}
