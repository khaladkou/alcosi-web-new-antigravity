# URL и i18n стратегия (переводы, canonical/hreflang, сохранение всех старых ссылок)

Документ фиксирует правила URL‑структуры, мультиязычности и **100% совместимости со старыми ссылками** при полной замене сайта на alcosi.com.

Главный принцип:  
**любой старый публичный URL обязан либо отдавать 200 с тем же контентом, либо делать 301 на канонический URL без цепочек редиректов.**

---

## 0) Цели и ключевые решения

### Цели
- **Сохранить все существующие ссылки** (маркетинговые страницы, статические ресурсы, статьи блога).
- Убрать SEO‑дубли (canonical + редиректы + нормализация URL).
- Добавить и поддерживать языки: `en`, `ru`, `pl`, `de`, `es`, `pt`.
- Сделать корректный `hreflang` и полноценный `sitemap.xml` (с языковыми альтернативами).
- Поддержать контент, приходящий по webhooks в формате JSON, включая многоязычные версии.

### Ключевые решения (обязательные)
1) **Slug у статьи должен быть свой для каждого языка** (локализованный slug).  
2) **Старые URL должны работать всегда** → используем **таблицу alias/redirect** и/или явный маппинг legacy‑путей.  
3) **Default‑язык без префикса** (рекомендуется, чтобы не ломать текущие маркетинговые URL), остальные языки с префиксом:  
   - default: `/...`  
   - не default: `/{locale}/...`  
   При этом `/{defaultLocale}/...` может существовать, но **должен 301 →** в без‑префиксную версию.
4) **Никаких redirect chains** (максимум 1 редирект до канонического).

> Если в текущем проде уже используются языковые префиксы для default‑языка — правило можно инвертировать (везде с префиксом), но тогда **все старые без‑префиксные URL** должны 301 → на новую схему. В любом случае применяется один канонический стандарт.

---

## 1) Термины

- **Канонический URL** — единственный URL, который должен индексироваться и быть основным для конкретной страницы/версии языка.
- **Legacy URL** — любой ранее существовавший публичный URL (включая дубли вроде `/alcosi/...`), который обязан продолжать работать.
- **Locale** — язык интерфейса/контента: `en`, `ru`, `pl`, `de`, `es`, `pt`.
- **Slug** — человекочитаемый идентификатор страницы/статьи в URL.

---

## 2) Канонизация и нормализация URL (MUST)

### 2.1 Протокол и домен
- **MUST:** всегда `https://alcosi.com` (все `http` → 301 на `https`).
- **MUST:** один основной хост (без дублей типа `www.`) → 301 на выбранный.

### 2.2 Trailing slash
- **MUST:** единая политика для всего сайта (например, **без** trailing slash).
  - `/blog/post` — канонично  
  - `/blog/post/` — 301 → `/blog/post`

### 2.3 Регистр
- **MUST:** все пути в нижнем регистре.
- **MUST:** если пришёл запрос с верхним регистром — 301 на lower‑case (если сервер позволяет безопасно).

### 2.4 Параметры запроса
- **MUST:** параметры, не влияющие на контент (utm и т.п.), не должны менять canonical.
- **SHOULD:** по возможности очищать/редиректить “мусорные” параметры, но аккуратно, чтобы не убить маркетинговую аналитику.

---

## 3) Стратегия локалей (i18n routing)

### 3.1 Поддерживаемые локали
- **MUST:** `en`, `ru`, `pl`, `de`, `es`, `pt`

### 3.2 Каноническая структура URL по языкам
Обозначим **defaultLocale** (например, `en` или `ru` — выбрать один).

**Канонический формат:**
- Default язык:  
  - страницы: `/<path>`  
  - блог: `/blog`, `/blog/<slug_default>`
- Остальные языки:  
  - страницы: `/{locale}/<path>`  
  - блог: `/{locale}/blog`, `/{locale}/blog/<slug_locale>`

**Редиректы для борьбы с дублями:**
- **MUST:** `/{defaultLocale}/...` → 301 → `/<...>` (если default без префикса).
- **MUST:** `/{locale}/...` для неизвестных locale → 404 (или 301 на default, но тогда осторожно с SEO).

### 3.3 Переключение языка
- **MUST:** переключатель языка ведёт на **соответствующую локализованную страницу**, если перевод есть.
- **Если перевода нет:**
  - **SHOULD:** вести на ближайший эквивалент (например, на список статей или на default‑версию) **с корректным canonical** (см. раздел 6).

---

## 4) Поддержка legacy‑дубликатов путей (например, `/alcosi/...`)

Если исторически существовали дубль‑пути с префиксом (например, `/alcosi/...`), то:

- **MUST:** все `^/alcosi(/.*)?$` → 301 → на соответствующий путь **без** `/alcosi`.
- **MUST:** редирект должен происходить **до** роутинга приложения (на уровне middleware/edge/server).

Пример:
- `/alcosi/blog/some-post` → 301 → `/blog/some-post`
- `/alcosi/pl/blog/jakis-post` → 301 → `/pl/blog/jakis-post`

---

## 5) Блог: маршруты и локализованные slugs (MUST)

### 5.1 Маршруты
- **MUST:** список статей:  
  - default: `/blog`  
  - не default: `/{locale}/blog`
- **MUST:** статья:  
  - default: `/blog/<slug_default>`  
  - не default: `/{locale}/blog/<slug_locale>`

### 5.2 Slug политика (обязательная)
- **MUST:** у каждой статьи есть перевод(ы), и **каждый перевод имеет свой slug**.
- **MUST:** slug **уникален в рамках языка**:
  - уникальность: `(locale, slug)`
- **MUST:** slug может меняться только через механизм alias/redirect (см. 5.3).
- **SHOULD:** slug — латиница + дефисы (`[a-z0-9-]`), без кириллицы, без `_`, без пробелов.

### 5.3 Сохранение старых ссылок при изменении slug (и миграции)
Чтобы **любой старый slug продолжал работать**, вводим механизм alias.

**Правило:**
- При любом изменении slug (или при импорте legacy URL) **создаём алиас** и на запрос старого пути отвечаем 301 на новый канонический.

Пример:
- Было (legacy): `/blog/top-ai-powered-seo-strategies-to-boost-your-website-ranking`  
- Стало (новый default slug): `/blog/ai-seo-strategies-2026`  
→ запрос старого URL должен давать: `301 Location: /blog/ai-seo-strategies-2026`

То же для локалей:
- Было: `/de/blog/top-ai-powered-seo-strategies-to-boost-your-website-ranking`  
- Стало: `/de/blog/ki-seo-strategien-ranking-verbessern`  
→ 301 на новый.

### 5.4 Гарантия “все старые ссылки поддержим”
Для гарантии требуется **инвентаризация** всех публичных URL старого сайта и фиксация в “карте миграции”.

- **MUST:** перед релизом собрать список:
  - все URL страниц сайта (маркетинг),
  - все URL статей блога (включая возможные варианты с `/alcosi`, с/без слеша, и т.п.).
- **MUST:** на основе списка сформировать таблицу `url_aliases` (или загрузить через админку).
- **MUST:** автотест (или чек‑лист) прогоняет все legacy URL → ожидается 200/301.

---

## 6) Canonical и hreflang для мультиязычности (MUST)

### 6.1 canonical
- **MUST:** canonical указывает на **канонический URL текущей языковой версии**.
- **MUST:** если страница доступна по нескольким URL (из‑за legacy, параметров, `/alcosi` и т.п.) — **все неканонические варианты должны 301** на канонический.

### 6.2 hreflang
На каждой индексируемой странице:
- **MUST:** добавить `<link rel="alternate" hreflang="xx" href="...">` для всех доступных языков этой страницы.
- **MUST:** добавить `hreflang="x-default"` на default‑версию.

Пример (для статьи):
- `hreflang="en"` → `/blog/<slug_en>` (или `/en/blog/...` если так выбрано)
- `hreflang="de"` → `/de/blog/<slug_de>`
- `hreflang="pl"` → `/pl/blog/<slug_pl>`
- и т.д.

### 6.3 Что делать, если перевода нет
Жёсткое правило (SEO‑безопасное):
- **MUST:** если для языка нет перевода статьи → `404` (страницы нет).
- **ALTERNATIVE (если бизнес требует показывать fallback):**
  - отдавать default‑контент, но ставить:
    - `meta robots: noindex, follow` для fallback‑страницы,
    - canonical на default‑URL,
    - и **не** добавлять hreflang на отсутствующий язык.

Рекомендация: для блога лучше 404, чтобы не плодить “псевдопереводы” и дубли.

---

## 7) Sitemap.xml и языковые альтернативы

### 7.1 Общие требования
- **MUST:** sitemap содержит **только канонические URL**.
- **MUST:** исключать `draft`/неопубликованные материалы.
- **SHOULD:** `lastmod` для URL берётся из `updated_at` (по соответствующему переводу, если ведётся отдельно).

### 7.2 Альтернативы языков в sitemap
Рекомендуется формат с `xhtml:link` внутри `url`:
- для каждой страницы/статьи указывать альтернативы `hreflang`.

Также допустимо:
- отдельный sitemap по каждому языку + sitemap index.

Главное: **в sitemap не должны попадать legacy URL** — только канонические.

---

## 8) Внутренние ссылки в HTML контенте (важно для переводов)

Поскольку контент статей приходит как HTML (внутри JSON), внутри него могут встречаться ссылки вида:
- `<a href="/catalog">...`

Правила:
- **MUST:** при рендере статьи для не‑default языков автоматически префиксировать внутренние ссылки на локализуемые маршруты:
  - на странице `/de/...` ссылка `/contact` → должна стать `/de/contact` (если `/contact` локализуется)
- **MUST:** не менять ссылки на:
  - внешние домены,
  - статические файлы (`/static/...`),
  - API (`/api/...`) и т.п.

Рекомендуется реализовать функцию `localizeInternalLinks(html, locale)`.

---

## 9) Модель данных в Postgres (рекомендовано)

### 9.1 Таблицы
**articles**
- `id` (PK)
- `status` (`draft|published|archived`)
- `published_at`, `created_at`, `updated_at`
- прочие общие поля (категория, автор и т.п.)

**article_translations**
- `id` (PK)
- `article_id` (FK → articles.id)
- `locale` (`en|ru|pl|de|es|pt`)
- `slug` (локализованный)
- `title`, `excerpt`
- `content_html`
- `meta_title`, `meta_description`
- `og_image_url` (опционально), `og_image_alt`
- `created_at`, `updated_at`
- **UNIQUE (`locale`, `slug`)**
- **UNIQUE (`article_id`, `locale`)**

**url_aliases** (универсальные редиректы/алиасы)
- `id` (PK)
- `from_path` (например, `/blog/old-slug` или `/alcosi/blog/old-slug`)
- `to_path` (канонический путь)
- `http_code` (обычно `301`)
- `created_at`
- **UNIQUE (`from_path`)**

> Примечание: alias можно хранить как “полный путь” (с locale в path) — это проще и универсальнее, чем пытаться разбирать по полям.

### 9.2 Алгоритм обработки входящего запроса (псевдологика)
1) Нормализовать URL (https, host, slash, lower-case — где применимо).
2) Проверить правило `/alcosi/*` → 301.
3) Проверить `url_aliases.from_path == request.path` → 301 на `to_path`.
4) Если это `/blog/...` или `/{locale}/blog/...`:
   - определить `locale` (default если нет префикса),
   - найти перевод по `(locale, slug)` в `article_translations`.
   - если не найдено → 404 (или fallback политика).
5) Для найденной статьи сформировать:
   - canonical,
   - hreflang,
   - meta.

---

## 10) Требования к webhook JSON (обновить контракт)

Текущий экспорт показывает, что статья имеет общий `article.slug`, а переводы приходят в объекте `translations` по ключам языков (например, `de`, `en`, `es`, `pl`, `pt`, `ru`).【7:9†articles_export_2_2026-01-15T05-34-30-367Z.json†L6-L35】【7:9†articles_export_2_2026-01-15T05-34-30-367Z.json†L30-L35】【5:2†articles_export_2_2026-01-15T05-34-30-367Z.json†L9-L13】

Чтобы реализовать **локализованные slugs**, контракт webhook должен содержать slug для каждого языка.

### 10.1 Новый обязательный формат (пример)
```json
{
  "article": {
    "id": 123,
    "status": "published",
    "published_at": "2026-01-11T13:30:28.795Z"
  },
  "translations": {
    "en": {
      "slug": "ai-seo-strategies-2026",
      "title": "…",
      "content_html": "…",
      "meta_description": "…"
    },
    "de": {
      "slug": "ki-seo-strategien-ranking-verbessern",
      "title": "…",
      "content_html": "…",
      "meta_description": "…"
    }
  }
}
```

### 10.2 Правила upsert
- **MUST:** идентификация статьи по стабильному `article.id` (или другому `source_id`, если так договоримся).
- **MUST:** upsert перевода по `(article_id, locale)`.
- **MUST:** если webhook приносит новый slug для существующего перевода:
  1) создать alias `from_path = старый канонический путь`
  2) обновить slug
- **MUST:** если новый slug конфликтует с уже существующим `(locale, slug)` → отклонить (409) и логировать.

---

## 11) QA‑чек‑лист (обязательный)

### 11.1 Совместимость URL
- Все legacy URL из инвентаря:
  - либо `200 OK`,
  - либо `301` на канонический URL.
- Нет цепочек редиректов (макс. 1).
- Нет “петель” редиректов.

### 11.2 SEO‑теги
- На каждой индексируемой странице:
  - `canonical` корректный,
  - `hreflang` полный и взаимный,
  - `x-default` указан.

### 11.3 Sitemap/robots
- sitemap отдаётся 200, содержит только канонические URL.
- robots.txt разрешает индексирование нужного, запрещает тех. зоны (admin/api).

---

## 12) Что обязательно согласовать до начала разработки
1) Какой **defaultLocale** (en или ru).
2) Политика fallback для отсутствующих переводов (404 vs noindex+canonical).
3) Есть ли исторические дубль‑пути кроме `/alcosi` (например, `/blog/` vs `/blog`).
4) Полный список legacy URL (можно CSV/JSON) для загрузки в `url_aliases`.
